c++ version


### 设计模式的原则(todo)

[开放-封闭原则](https://www.cnblogs.com/gaochundong/p/open_closed_principle.html)

    对于继承是开放的，对于修改时封闭的。

## 创建型模式

### singleton 单例模式

[代码](../c%2B%2B/singleton.cpp)
 
[单例模式](https://zhuanlan.zhihu.com/p/37469260)
[使用锁机制来保护](https://zhuanlan.zhihu.com/p/83539039)

### 简单工厂模式->工厂方法->模板工厂（todo）
[简单工厂](../c%2B%2B/simple_factor.cpp)->[工厂方法](../c%2B%2B/factor_method.cpp)->[模板工厂](../c%2B%2B/template_factory.cpp)

[深入浅出工厂模式](https://zhuanlan.zhihu.com/p/83535678)

### 原型模式

原型模式是一种创建型设计模式，使你能复制已有对象，而又无需使代码依赖它们所属的类。

1. 优缺点


|优点| 缺点|
|---|---|
|你可以克隆对象， 而无需与它们所属的具体类相耦合。| 克隆包含循环引用的复杂对象可能会非常麻烦。|
|你可以克隆预生成原型， 避免反复运行初始化代码。||
|你可以更方便地生成复杂对象。||
| 你可以用继承以外的方式来处理复杂对象的不同配置。||
2. uml图

![Clone](../pic/design_pattern/clone.png)

3. 代码实现

[Clone](../c%2B%2B/design_pattern/Clone.cpp)

4. 与其他模式的关系

在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。

>參考

[原型模式](https://refactoringguru.cn/design-patterns/prototype)
[原型模式](https://zhuanlan.zhihu.com/p/365222623)


### 建造模式（todo）

1. 优缺点


|优点| 缺点|
|---|---|
|||


2. uml图

![](../pic/design_pattern/)

3. 代码实现

[](../c%2B%2B/design_pattern/)

4. 与其他模式的关系



## 结构型模式


### 代理模式

也称 Proxy,是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。

1. 优缺点


|优点| 缺点|
|---|---|
|你可以在客户端毫无察觉的情况下控制服务对象。| 代码可能会变得复杂， 因为需要新建许多类。|
| 如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。|服务响应可能会延迟。|
|即使服务对象还未准备好或不存在， 代理也可以正常工作。||
|开闭原则||

2. uml图

![proxy](../pic/design_pattern/Proxy.png)

3. 代码实现

[Proxy](../c%2B%2B/design_pattern/Proxy.cpp)

4. 与其他模式的关系

适配器模式能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰模式则能为对象提供加强的接口。

外观模式与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。

装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。


>参考

[代理模式](https://refactoringguru.cn/design-patterns/proxy)


### 享元模式


1. 优缺点

|优点| 缺点|
|---|---|
| 如果程序中有很多相似对象， 那么你将可以节省大量内存。|你可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。|
||代码会变得更加复杂。|

2. uml图

![Flyweight](../pic/design_pattern/Flyweight.png)



3. 代码实现，实现了预先分配内存的版本。根据需求创建元素的话，可以通过修改getFlyweight方法：添加判断逻辑，Flyweight中如果没有key，添加元素；如果有返回结果。

[Flyweight.cpp](../c%2B%2B/design_pattern/Flyweight.cpp)

>参考

[享元模式](https://refactoringguru.cn/design-patterns/flyweight)



### 组合模式

亦称对象树(Object Tree),Composite

1. 优缺点

|优点| 缺点|
|---|---|
| 你可以利用多态和递归机制更方便地使用复杂树结构| 对于功能差异较大的类， 提供公共接口或许会有困难。|
|开闭原则。||

2. uml图

![composite](../pic/design_pattern/composite.png)



3. 代码实现

[composite.cpp](../c%2B%2B/design_pattern/composite.cpp)

(todo)遍历访问的时候是倒置的树,需翻转180度。


4. 组合模式和桥接模式，状态模式，策略模式的接口非常相似。实际上，他们都是基于组合模式---即将工作委派给其他对象。

组合和责任链模式结合使用，可以将请求沿包含全体父组件的链一直传递到对象树的底部。
组合模式和迭代器模式来遍历组合树。
使用访问者模式对整个组合树来执行操作。
享元模式实现组合树的共享叶节点以节省内存。
组合和装饰模式的结构图很相似，两者都依赖递归组合来组织无限数量的对象。

>参考

[组合模式](https://refactoringguru.cn/design-patterns/composite)

### 桥接模式

桥接模式是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。

1. 优缺点

|优点| 缺点|
|---|---|
| 你可以利用多态和递归机制更方便地使用复杂树结构|对高内聚的类使用该模式可能会让代码更加复杂|
|客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。||
|开闭原则。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。||
| 单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。||

2. uml图

![bridge](../pic/design_pattern/bridge.png)

3. 代码实现

[Bridge](../c%2B%2B/design_pattern/Bridge.cpp)

4. 与其他模式的关系


桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。

桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题

你可以将抽象工厂模式和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。

你可以结合使用生成器模式和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。



### 装饰模式

 装饰者模式(Decorator)、装饰器模式(Wrapper)

1. 优缺点


|优点| 缺点|
|---|---|
|你无需创建新子类即可扩展对象的行为。|在封装器栈中删除特定封装器比较困难。|
| 你可以在运行时添加或删除对象的功能。| 实现行为不受装饰栈顺序影响的装饰比较困难。|
| 你可以用多个装饰封装对象来组合几种行为。|各层的初始化配置代码看上去可能会很糟糕。|
| 单一职责原则。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类。||

2. uml图

![Decorator](../pic/design_pattern/decorator.png)

3. 代码实现

[Decorator](../c%2B%2B/design_pattern/Decorator.cpp)

4. 与其他模式的关系


### 外观模式（todo）

1. 优缺点


|优点| 缺点|
|---|---|
|||


2. uml图

![](../pic/design_pattern/)

3. 代码实现

[](../c%2B%2B/design_pattern/)

4. 与其他模式的关系



## 行为模式


### 订阅模式(观察者模式)


### 中介模式

1. 优缺点

|优点| 缺点|
|---|---|
|单一职责|中介者可能会成为上帝都对像|
|开放-封闭原则||
|减轻多个组件之间的耦合||

2. uml图

![mediator模式](../pic/design_pattern/mediator.png)

3. 代码实现

[mediator.cpp](../c%2B%2B/design_pattern/mediator.cpp)

>参考

[C++ 中介者模式讲解和代码示例](https://refactoringguru.cn/design-patterns/mediator/cpp/example)



### 职责链模式

又称：责任链模式（Chain of Responsibility）、命令链（CoR，Chain of Command）

1. 优缺点

|优点| 缺点|
|---|---|
| 你可以控制请求处理的顺序。|部分请求可能未被处理。|
|单一职责原则。 你可对发起操作和执行操作的类进行解耦。||
|开闭原则。||

2. uml图

![chain_responsibility](../pic/design_pattern/chain_responsibility.png)



3. 代码实现

[chain_responsibility.cpp](../c%2B%2B/design_pattern/chain_responsibility.cpp)

>参考

[职责链模式](https://refactoringguru.cn/design-patterns/chain-of-responsibility)




### 状态模式

让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。

1. 优缺点


|优点| 缺点|
|---|---|
| 单一职责原则。 将与特定状态相关的代码放在单独的类中|如果状态机只有很少的几个状态， 或者很少发生改变， 那么应用该模式可能会显得小题大作。|
|开闭原则。 无需修改已有状态类和上下文就能引入新状态。||
|通过消除臃肿的状态机条件语句简化上下文代码。||

2. uml图

![state](../pic/design_pattern/state.png)

3. 代码实现

[State](../c%2B%2B/design_pattern/State.cpp)

4. 与其他模式的关系

桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。

状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。


### 命令模式

也称动作(Action)，事务(Transaction)，命令（Command）

它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。

1. 优缺点

|优点| 缺点|
|---|---|
|单一职责原则 |代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次。|
|开闭原则||
|可以实现撤销和恢复功能||
|可以操作的延迟执行||
|可以将一组简单命令组合成复杂命令||

2. uml图

![command](../pic/design_pattern/command.png)

3. 代码实现

[Command](../c%2B%2B/design_pattern/Command.cpp)

4. 与其他模式的关系

责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。

命令在发送者和请求者之间建立单向连接。

中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。

观察者允许接收者动态地订阅或取消接收请求。

### 策略模式

也称Strategy，策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。


1. 优缺点


|优点| 缺点|
|---|---|
|你可以在运行时切换对象内的算法。| 如果你的算法极少发生改变， 那么没有任何理由引入新的类和接口。 使用该模式只会让程序过于复杂。|
| 你可以将算法的实现和使用算法的代码隔离开来。| 客户端必须知晓策略间的不同——它需要选择合适的策略。|
| 你可以使用组合来代替继承。| 许多现代编程语言支持函数类型功能， 允许你在一组匿名函数中实现不同版本的算法。 |
|开闭原则。 你无需对上下文进行修改就能够引入新的策略。||


2. uml图

![strategy](../pic/design_pattern/strategy.png)

3. 代码实现

[Strategy](../c%2B%2B/design_pattern/Strategy.cpp)

4. 与其他模式的关系

命令模式和策略看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。

* 你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。

* 另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。

装饰模式可让你更改对象的外表， 策略则让你能够改变其本质。

模板方法模式基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。

状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。



### 模板方法模式（todo）

1. 优缺点


|优点| 缺点|
|---|---|
|||


2. uml图

![](../pic/design_pattern/)

3. 代码实现

[](../c%2B%2B/design_pattern/)

4. 与其他模式的关系

### 观察者模式（todo）

1. 优缺点


|优点| 缺点|
|---|---|
|||


2. uml图

![](../pic/design_pattern/)

3. 代码实现

[](../c%2B%2B/design_pattern/)

4. 与其他模式的关系


### 备忘录模式（todo）

1. 优缺点


|优点| 缺点|
|---|---|
|||


2. uml图

![](../pic/design_pattern/)

3. 代码实现

[](../c%2B%2B/design_pattern/)

4. 与其他模式的关系


### 迭代器模式（todo）

1. 优缺点


|优点| 缺点|
|---|---|
|||


2. uml图

![](../pic/design_pattern/)

3. 代码实现

[](../c%2B%2B/design_pattern/)

4. 与其他模式的关系

### 访问者模式（todo）

1. 优缺点


|优点| 缺点|
|---|---|
|||


2. uml图

![](../pic/design_pattern/)

3. 代码实现

[](../c%2B%2B/design_pattern/)

4. 与其他模式的关系



